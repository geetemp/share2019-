### 浅谈浏览器的运行机制

上周我们探讨了一个经典的面试题即：用户使用浏览器输入url到页面呈现，经历了哪些过程。我们现在来回顾一下：

- 用户输入url地址

- dns解析，得到web服务器的ip和端口号

   	这个大概包含以下步骤浏览器缓存、系统缓存、路由器缓存、ISP(互联网服务提供商)DNS缓存、根域名服务器、顶级域名服务器、主域名服务器等。解析从前向后解析，返回结果从后向前返回结果，如果没有，则立即缓存。

- 浏览器与web服务器进行tcp连接(长连接、三次握手)

- 浏览器向服务器发送http请求报文

- 浏览器解析资源，生成domtree，和cssom

- domtree和cssom 形成rendertree

- 根据rendertree进行layout

- 渲染rendertree

那么今天我们来探讨一下浏览器解析资源的这个过程，以及在这个过程中我们有哪些可以优化的点。

#### 浏览器的组成

首先我们先声明一下，浏览器是一个多进程的。有兴趣的话可以打开chrome浏览的任务管理器，可以发现chrome有多个进程(没个tab页面是一个进程，browser进程，gpu进程，插件进程等)

那么这些进程都是用来干什么的呢？

- browser进程： 是浏览器的主进程，负责主控，协调，只有一个，可以看做是浏览器的大脑。
  - 负责下载页面中的网络资源
  - 负责渲染页面
  - 创建销毁tab页面
  - 负责用户交互
- GPU进程，负责3D绘制，只有当该页面使用了硬件加速才会使用它，来渲染（显示）页面。否则的话，不使用这个进程，而是用Browser进程来渲染（显示）页面
- render进程：又名浏览器内核，每个tab页面对应一个独立的renderer进程，内部有多个线程 。
- 第三方插件进程：每种类型的插件对应一个进程 。

浏览器是多进程的好处非常明显，如果是单进程的话，一个tab页面假死、崩溃导致整个浏览器崩溃，那是非常不友好的。接下来我们着重来介绍一个render进程，也就是浏览器内核。

#### 浏览器内核

上面我们讲到浏览器内核是一个多线程的，那么它又有哪些线程呢？

- JS引擎线程
  - 也叫js内核，用于解析js脚本，执行代码
  - 与GUI线程互斥，即当js引擎线程运行时，GUI线程会被挂起，当js引擎线程结束运行时，才会继续运行GUI线程
  - 由一个主线程和多个web worker线程组成，由于web worker是附属于主线程，无法操作dom等，所以js还是单线程语言（在主线程运行js代码）
- GUI渲染线程
  - 用于解析html为DOM树，解析css为CSSOM树，布局layout，绘制paint。
  - 当页面需要重排reflow，重绘repaint时，使用该线程
  - 与js引擎线程互斥
- 事件触发线程
  - 当对应事件触发（不论是WebAPIs完成事件触发，还是页面交互事件触发）时，该线程会将事件对应的回调函数放入callback queue（任务队列）中，等待js引擎线程的处理。
- 定时器触发线程
  - 对应于setTimeout，setInterval API，由该线程来计时，当计时结束，将事件对应的回调函数放入任务队列中
  - 当setTimeout的定时的时间小于4ms，一律按4ms来算
- http请求线程
  - 每有一个http请求就开一个该线程
  - 当检测到状态变更的话，就会产生一个状态变更事件，如果该状态变更事件对应有回调函数的话，则放入任务队列中
- 任务队列轮训线程
  - 用于轮询监听任务队列，以知道任务队列是否为空

#### HTML解析

 html解析包含有一系列的步骤，过程为**Bytes -> Characters -> Tokens -> Nodes -> DOM。**最终将html解析为DOM树。

  假设有一html页面，代码如下：

```html
<html>
  <head>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <link href="style.css" rel="stylesheet">
    <title>Critical Path</title>
  </head>
  <body>
    <p>Hello <span>web performance</span> students!</p>
    <div><img src="awesome-photo.jpg"></div>
  </body>
</html>
```

![html解析](https://tt9.geetemp.com/geebox/images/html解析.png)

最终形成DOM树。如果想了解更深的解析，参考 [How Browers Work](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/)

#### CSS解析

 与html解析类似，他解析最终形成CSSOM树，过程为**Bytes -> Characters -> Tokens -> Nodes -> CSSOM。**

  假设css代码如下：

```css
body { font-size: 16px }
p { font-weight: bold }
span { color: red }
p span { display: none }
img { float: right }
```

 得到的CSSOM为：  

![CSS解析](https://tt9.geetemp.com/geebox/images/CSS解析.png)

#### css权重值

css由4中权重等级的定义如下：

- 内联样式 ， 如 `style=""`,参考权值为1000
- id 选择器， 如 `#content{}` ,参考权值为100
- 类，伪类，属性选择器，如`.content{}`，参考权值为10
- 元素和伪元素选择器，如 `h1{} :before{}`,参考权值为1 

权重的规则：

- 相同权重，后出现的选择器为最后规则
- 不同权重，权重高值生效
- 无论多少个低等级选择器，都不如一个高等级选择器(如11个id选择器权重没有一个行内选择器的权重高)
- `!important ` 权重最高，慎用

#### render树

由DOM树与CSS树结合形成的渲染树（其中无法显示的元素，如script，head元素或diplay：none的元素，不会在渲染树中，也就最终不会被渲染出来），**页面的布局，绘制都是以render树为依据。** 

由以上的DOM树与CSSOM树，最终得到的渲染树如下：

![redner tree](https://tt9.geetemp.com/geebox/images/redner tree.png)

 #### layout

​	创建render tree后，下一步就是布局（Layout）,或者叫回流（reflow,relayout），这个过程就是通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸，将其安置在浏览器窗口的正确位置，而有些时候我们会在文档布局完成后对DOM进行修改，这时候可能需要重新进行布局，也可称其为回流，本质上还是一个布局的过程，每一个渲染对象都有一个布局或者回流方法，实现其布局或回流。 

​	大多数web应用对DOM的操作都是比较频繁，这意味着经常需要对DOM进行布局和回流，而如果仅仅是一些小改变，就触发整个渲染树的回流，这显然是不好的，为了避免这种情况，浏览器使用了脏位系统，只有一个渲染对象改变了或者某渲染对象及其子渲染对象脏位值为”dirty”时，说明需要回流。

 	表示需要布局的脏位值有两种 ：

- “dirty”–自身改变，需要回流 
- “children are dirty”–子节点改变，需要回流 

		布局是一个从上到下，从外到内进行的递归过程，从根渲染对象，即对应着HTML文档根元素，然后下一级渲染对象，如对应着元素，如此层层递归，依次计算每一个渲染对象的几何信息（位置和尺寸）。

每一个渲染对象的布局流程基本如下：

- 计算此渲染对象的宽度（width） 
- 遍历此渲染对象的所有子级，依次 
  - 设置子级渲染对象的坐标 
  - 判断是否需要触发子渲染对象的布局或回流方法，计算子渲染对象的高度 
- 设置此渲染对象的高度：根据子渲染对象的累积高，margin和padding的高度设置其高度 
- 设置此渲染对象脏位值为false。

 #### 绘制

在绘制阶段，系统会遍历呈现树，并调用呈现器的“paint”方法，将呈现器的内容显示在屏幕上。绘制工作是GUI线程完成的。

CSS2 规范定义了绘制流程的顺序。绘制的顺序其实就是元素进入堆栈样式上下文的顺序。这些堆栈会从后往前绘制，因此这样的顺序会影响绘制。块呈现器的堆栈顺序如下： 

- 背景颜色 
- 背景图片
- 边框
- 子代
- 轮廊

#### 回流与重绘

回流： 重新布局(layout)叫回流  

重绘： 重新绘制操作叫重绘

那么，什么时候会发生回流与重绘呢？

-  当页面的某部分元素发生了尺寸、位置、隐藏发生了改变，页面进行回流。得对整个页面重新进行布局计算，将所有尺寸，位置受到影响的元素回流 。 直白的讲，这个元素发生的变化影响到布局了，就需要重新布局即回流
- 当页面的某部分元素的外观发生了改变，但尺寸、位置、隐藏没有改变，页面进行重绘。（同样，只重绘部分元素，而不是整个页面重绘）

 **回流的同时往往会伴随着重绘，重绘不一定导致回流。**所以回流导致的代价是大于重绘的。

 网上有两个很有意思的动图，形容的非常形象，大家参考一下：

![回流](https://tt9.geetemp.com/geebox/images/回流.gif)

![重绘](https://tt9.geetemp.com/geebox/images/%E9%87%8D%E7%BB%98.gif)

那么具体到什么操作会导致回流呢，[参考链接](https://gist.github.com/paulirish/5d52fb081b3570c81e3a)？

- 页面初始化渲染
- 窗口的尺寸变化
- 元素的尺寸、位置、隐藏变化
- dom结构发生变化
- 获取某些属性，如：
  - offset
  - client
  - scroll
  - getComputedStyle
  - width
  - height
- 字体大小
- 内容更新

如何减少回流？

- 减少逐项更改样式，最好一次性更改style，或是将更改的样式定义在class中并一次性更新
- 避免循环操作DOM，而是新建一个节点，在他上面应用所有DOM操作，然后再将他接入到DOM中
- 当要频繁得到如offset属性时，只读取一次然后赋值给变量，而不是每次都获取一次
- 将复杂的元素绝对定位或固定定位，使他脱离文档流，否则回流代价很高
- 使用硬件加速创建一个新的复合图层，当其需要回流时不会影响原始复合图层回流

#### 硬件加速

在未开启硬件加速的时候是使用cpu来渲染页面，只有开启了硬件加速了，才会使用到GPU渲染页面。

在介绍硬件加速之前，先来理解一下简单图层和复合图层。

简单图层：dom中的没个节点对应一个简单图层。

复合图层是简单图层的合并，一个页面只有一个复合图层，无论你创建了多少个元素，都是在这个复合图层中。

注意：absolute、fixed布局，可以使该元素脱离文档流，但还是在这个复合图层中，所以他还是会影响复合图层的绘制，但不会影响重排 。

 **当一个元素使用硬件加速后，会生成一个新的复合图层**，这样不管其如何变化，都不会影响原复合图层。不过不要大量使用硬件加速，会导致资源消耗过度，导致页面也卡。

  所以，使用了硬件加速后，会有多个复合图层，然后多个复合图层互相独立，单独布局、绘制。

 那么，关键点来了，如何才能硬件加速？

- translate3d,translateZ  
- opacity属性

 硬件加速是请务必使用z-index属性，因为当一个元素使用了硬件加速，那么它后面的元素如果z-index比他大或者相同，并且absoulte或者fiexd的属性相同的话，则默认这些元素也创建各自的复合图层，就会导致硬件加速过多。所以我们使用单独的z-index来避免这种情况。

#### CSS堵塞

首先，Browser进程中下载css文件，当下载完成后，发送给GUI线程 

其次，是在GUI线程中解析html及css，不过这两者是并行的。 

由于css的下载和解析不会影响DOM树，所以**不会堵塞html文件的解析，但会堵塞页面渲染。** 

这样的设计是非常合理的，如果css文件的下载和解析不会堵塞页面渲染，那么在页面渲染的途中或结束后发现元素样式有变化，则又需要回流和重绘。 

由于css下载并不影响html的解析，所以越早引入约好。可以做到同时解析。

#### js堵塞

**js文件的下载和解析执行都会堵塞html文件的解析及页面渲染** 。为js脚本可能会改变DOM结构，若是其不堵塞html文件的解析及页面渲染的话，那么当js脚本改变DOM结构或元素样式时，会引发回流和重绘，会造成不必要的性能浪费，不如等待js执行完，在进行html解析和页面渲染。 

如果你不想js下载堵塞的话，可以使用async属性，这样可以异步加载js文件，加载完之后立即执行，执行的时候仍然和gui线程互斥，所以js执行的时候，也是不会渲染的。

如果需要在DOM数完成执行执行js的话，把js放在head中，其它情况建议放在body元素的末尾。

#### async defer

![async defer](https://tt9.geetemp.com/geebox/images\async defer.jpg)

#### js的事件循环机制

首先我们先来看一张图

![事件循环](https://tt9.geetemp.com/geebox/images/事件循环.png)



上图的执行书序如下：

1、线程读取JS代码，此时为同步环境，形成相应的堆和执行栈； 

2、主线程遇到异步任务，指给对应的异步进程进行处理（WEB API）; 

3、异步进程处理完毕（Ajax返回、DOM事件处罚、Timer到等），将相应的异步任务推入任务队列； 

4、主线程执行完毕，查询任务队列，如果存在任务，则取出一个任务推入主线程处理（先进先出）； 

5、 重复执行step2、3、4；称为事件循环。 

##### 任务队列

任务队列的类型有两种宏任务(macrotask)和微任务(microtask)

宏任务：主代码块和任务队列中的回调函数就是宏任务 ，为了使js内部宏任务和DOM任务能够有序的执行，每次执行完宏任务后，会在下一个宏任务执行之前，对页面重新进行渲染 。宏任务除了主代码块之外还有以下api：`setTimeout`, `setInterval`, `setImmediate`, I/O, UI rendering 

微任务：再宏任务执行的过程中，执行到微任务时，将微任务放入微任务队列中。它在宏任务执行后，重新渲染之前执行。当一个宏任务执行后，它会讲产生的所有的微任务执行完。微任务有以下api：`process.nextTick`, `Promises`, `Object.observe`(废弃), `MutationObserver` 。

那么我们通过下面这段代码来论证一下我们的说法：

```javascript
  	console.log(1)
    setTimeout(macroCallback, 0);
    new Promise(function(resolve, reject) {
        console.log(2)
        resolve();
        console.log(3)
    }).then(microCallback);

    function macroCallback() {
        console.log(4,)
    } 

    function microCallback() {
        console.log(5)
    }     
```

